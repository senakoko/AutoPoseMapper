import numpy as np
from scipy.io import loadmat
from autoposemapper.setRunParameters import set_run_parameter


def reorient(original_mat, predicted_mat, bind_center_value=None, b1_value=None, b2_value=None,
             silent=False):
    """
    Reorients the body part points back to their original positions.

    Parameters
    ----------
    original_mat: the file generated by the egocenter function.
    predicted_mat: the predicted file from the autoencoder
    bind_center_value: string -  the middle point to use in ego-centering
    b1_value: string - the start point to use to ego-center
    b2_value: string - the end point to use to ego-center
    silent: boolean -  Show the process of ego-centering the data

    Returns
    -------
    predicted_2D: the reoriented data
    """
    parameters = set_run_parameter()
    ori_d = loadmat(original_mat)
    predicted_data = loadmat(predicted_mat)
    ori_vals = ori_d[parameters.animal_key]
    predicted_vals = predicted_data[parameters.animal_key]

    # Transform to 3D
    ori_mat = ori_vals.reshape((ori_vals.shape[0], int(ori_vals.shape[1] / 2), 2))
    predict_mat = predicted_vals.reshape((predicted_vals.shape[0], int(predicted_vals.shape[1] / 2), 2))

    # This is not the best but tqdm always has this error that module is not callable
    from tqdm import tqdm

    # returns all points except bind center
    ginds = np.setdiff1d(np.arange(ori_mat.shape[1]), bind_center_value)
    # subtracts bind center from each point
    ego_mat = ori_mat[:, :, :2] - ori_mat[:, [bind_center_value for i in range(ori_mat.shape[1])], :2]
    # index all points except for the bind center
    ego_mat = ego_mat[:, ginds]

    dir_arr = ego_mat[:, b1_value] - ego_mat[:, b2_value - 1]
    # creates the directional array
    dir_arr = dir_arr / np.linalg.norm(dir_arr, axis=1)[:, np.newaxis]

    if not silent:
        for t in tqdm(range(predict_mat.shape[0])):
            # creates a 2x2 of the mid-point between b1_value and b2_value
            rot_mat = np.array([[dir_arr[t, 0], -dir_arr[t, 1]], [dir_arr[t, 1], dir_arr[t, 0]]])
            # dot multiply each body part by the mid-point between b1_value and b2_value to perform rotation
            predict_mat[t] = np.array(np.dot(predict_mat[t], rot_mat.T))
    elif silent:
        for t in range(predict_mat.shape[0]):
            rot_mat = np.array([[dir_arr[t, 0], -dir_arr[t, 1]], [dir_arr[t, 1], dir_arr[t, 0]]])
            predict_mat[t] = np.array(np.dot(predict_mat[t], rot_mat.T))

    predict_mat = predict_mat + ori_mat[:, [bind_center_value for i in range(ori_mat.shape[1] - 1)], :2]

    predicted_2D = predict_mat.reshape(predict_mat.shape[0], (predict_mat.shape[1] * predict_mat.shape[2]))

    return predicted_2D
